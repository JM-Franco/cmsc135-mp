LEFT EQU 0
TOP EQU 2
ROW EQU 15
COL EQU 40
RIGHT EQU LEFT+COL
BOTTOM EQU TOP+ROW

.MODEL SMALL
.DATA          
    INTRO_MSG DB "WELCOME TO SNAKE",0
    INSTRUCTIONS DB 0AH,0DH,"USE W, A, S AND D OR THE ARROW KEYS TO CONTROL YOUR SNAKE",0AH,0DH,"USE Q ANYTIME TO QUIT",0DH,0AH, "PRESS ANY KEY TO CONTINUE$"
    QUIT_MSG DB "THANKS FOR PLAYING!",0
    GG_MSG DB "GAME OVER!", 0
    SCORE_MSG DB "SCORE: ",0
    HEAD DB '^',10,10
    BODY DB '**',10,42, 3*546 DUP(0)
    CHAR_COUNT DB 2
    FOOD_ACTIVE DB 1
    FOOD_X DB 8
    FOOD_Y DB 8
    GAMEOVER DB 0
    QUIT DB 0 
    DELAY_TIME DB 5

.STACK
    DW   128  DUP(0)

.CODE

MAIN PROC FAR
	MOV AX,@DATA
	MOV DS,AX 
	
	MOV AX,0B800H
	MOV ES,AX
	
	;CLEARING THE SCREEN
	MOV AX,3H
	INT 10H
	
	LEA BX, INTRO_MSG
	MOV DX,0H
	CALL PRINT_STRING
	
	LEA DX, INSTRUCTIONS
	MOV AH, 09H
	INT 21H
	
	MOV AH, 07H
	INT 21H
	MOV AX, 0003H
	INT 10H
    CALL PRINT_BOARD      
    
    
MAINLOOP:       
    CALL DELAY             
    LEA BX, INTRO_MSG
    MOV DX, 00
    CALL PRINT_STRING
    CALL SNAKE_MOVE
    CMP GAMEOVER,1
    JE GAMEOVER_MAINLOOP
    
    CALL KEYBD_INPUT
    CMP QUIT, 1
    JE QUITPRESSED_MAINLOOP
    CALL FOOD_SPAWN
    CALL DRAW
    
    ;TODO: CHECK GAMEOVER AND QUIT
    
    JMP MAINLOOP
    
GAMEOVER_MAINLOOP: 
    MOV AX, 0003H
    INT 10H
    MOV DELAY_TIME, 100
    MOV DX, 0000H
    LEA BX, GG_MSG
    CALL PRINT_STRING    
    LEA BX, SCORE_MSG
    MOV DX, 0100H
    CALL PRINT_STRING
    ADD DX, 7
    CALL SET_CURSOR
    MOV AL, CHAR_COUNT
    DEC AL
    DEC AL
    XOR AH, AH
    CALL PRINT_NUM
    CALL DELAY    
    JMP QUIT_MAINLOOP    
    
QUITPRESSED_MAINLOOP:
    MOV AX, 0003H
	INT 10H    
    MOV DELAY_TIME, 100
    MOV DX, 0000H
    LEA BX, QUIT_MSG
    CALL PRINT_STRING
    CALL DELAY    
    JMP QUIT_MAINLOOP    

QUIT_MAINLOOP:
;FIRST CLEAR SCREEN
MOV AX, 0003H
INT 10H    
MOV AX, 4C00H
INT 21H  

DELAY PROC 
    
    ;THIS PROCEDURE USES 1A INTERRUPT, MORE INFO CAN BE FOUND ON   
    ;HTTP://WWW.COMPUTING.DCU.IE/~RAY/TEACHING/CA296/NOTES/8086_BIOS_AND_DOS_INTERRUPTS.HTML
    MOV AH, 00
    INT 1AH
    MOV BX, DX
    
JMP_DELAY:
    INT 1AH
    SUB DX, BX
    ;THERE ARE ABOUT 18 TICKS IN A SECOND, 10 TICKS ARE ABOUT ENOUGH
    CMP DL, DELAY_TIME                                                      
    JL JMP_DELAY    
    RET
    
DELAY ENDP

FOOD_SPAWN PROC
    MOV CH, FOOD_Y
    MOV CL, FOOD_X
SPAWN:
    CMP FOOD_ACTIVE, 1
    JE RET_FOOD_ACTIVE
    MOV AH, 00
    INT 1AH
    ;DX CONTAINS THE TICKS
    PUSH DX
    MOV AX, DX
    XOR DX, DX
    XOR BH, BH
    MOV BL, ROW
    DEC BL
    DIV BX
    MOV FOOD_Y, DL
    INC FOOD_Y
    
    POP AX
    MOV BL, COL
    DEC DL
    XOR BH, BH
    XOR DX, DX
    DIV BX
    MOV FOOD_X, DL
    INC FOOD_X
    
    CMP FOOD_X, CL
    JNE NEVERMIND
    CMP FOOD_Y, CH
    JNE NEVERMIND
    JMP SPAWN             
NEVERMIND:
    MOV AL, FOOD_X
    ROR AL,1
    JC SPAWN
    
    ADD FOOD_Y, TOP
    ADD FOOD_X, LEFT 
    
    MOV DH, FOOD_Y
    MOV DL, FOOD_X
    CALL READ_CHAR
    CMP BL, '*'
    JE SPAWN
    CMP BL, '^'
    JE SPAWN
    CMP BL, '<'
    JE SPAWN
    CMP BL, '>'
    JE SPAWN
    CMP BL, 'V'
    JE SPAWN    
    
RET_FOOD_ACTIVE:
    RET
FOOD_SPAWN ENDP

PRINT_DIGIT PROC
    ADD DL, '0'
    MOV AH, 02H
    INT 21H
    RET
PRINT_DIGIT ENDP   
   
PRINT_NUM PROC    
    TEST AX,AX
    JZ RETZ
    XOR DX, DX
    ;AX CONTAINS THE NUMBER TO BE DISPLAYED
    ;BX MUST CONTAIN 10
    MOV BX,10
    DIV BX
    ;PRINT_NUM AX FIRST.
    PUSH DX
    CALL PRINT_NUM  
    POP DX
    CALL PRINT_DIGIT
    RET
RETZ:
    MOV AH, 02  
    RET    
PRINT_NUM ENDP   

;SETS THE CURSOR POSITION, AX AND BX USED, DH=ROW, DL = COLUMN
;PRESERVES OTHER REGISTERS
SET_CURSOR PROC
    MOV AH, 02H
    PUSH BX
    MOV BH,0
    INT 10H
    POP BX
    RET
SET_CURSOR ENDP

DRAW PROC
    LEA BX, SCORE_MSG
    MOV DX, 0109
    CALL PRINT_STRING
    
    ADD DX, 7
    CALL SET_CURSOR
    MOV AL, CHAR_COUNT
    DEC AL
    DEC AL
    XOR AH, AH
    CALL PRINT_NUM
        
    LEA SI, HEAD
DRAW_LOOP:
    MOV BL, DS:[SI]
    TEST BL, BL
    JZ OUT_DRAW
    MOV DX, DS:[SI+1]
    CALL PRINT_CHAR
    ADD SI,3   
    JMP DRAW_LOOP 

OUT_DRAW:
    MOV BL, '0'
    MOV DH, FOOD_Y
    MOV DL, FOOD_X
    CALL PRINT_CHAR
    MOV FOOD_ACTIVE, 1
    
    RET
   
DRAW ENDP

;DL CONTAINS THE ASCII CHARACTER IF KEYPRESSED, ELSE DL CONTAINS 0
;USES DX AND AX, PRESERVES OTHER REGISTERS
READ_KEYBD PROC
    MOV AH, 01H
    INT 16H
    JNZ KEYBDPRESSED
    XOR DL, DL
    RET
KEYBDPRESSED:
    ;EXTRACT THE KEYSTROKE FROM THE BUFFER
    MOV AH, 00H
    INT 16H
    MOV DL,AL
    RET

READ_KEYBD ENDP                    
         
KEYBD_INPUT PROC
    
    CALL READ_KEYBD
    CMP DL, 0
    JE NEXT_14
    
    ;SO A KEY WAS PRESSED, WHICH KEY WAS PRESSED THEN SOLTI?
    CMP DL, 'W'
    JNE NEXT_11
    CMP HEAD, 'V'
    JE NEXT_18
    MOV HEAD, '^'
    RET
NEXT_11:
    CMP DL, 'S'
    JNE NEXT_12
    CMP HEAD, '^'
    JE NEXT_18
    MOV HEAD, 'V'
    RET
NEXT_12:
    CMP DL, 'A'
    JNE NEXT_13
    CMP HEAD, '>'
    JE NEXT_18
    MOV HEAD, '<'
    RET
NEXT_13:
    CMP DL, 'D'
    JNE NEXT_14
    CMP HEAD, '<'
    JE NEXT_18
    MOV HEAD,'>'
NEXT_14:
    CMP AH, 48H
    JNE NEXT_15
    CMP HEAD, 'V'
    JE NEXT_18
    MOV HEAD, '^'
    RET
NEXT_15:
    CMP AH, 50H
    JNE NEXT_16
    CMP HEAD, '^'
    JE NEXT_18
    MOV HEAD, 'V'
    RET
NEXT_16:
    CMP AH, 4BH
    JNE NEXT_17
    CMP HEAD, '>'
    JE NEXT_18
    MOV HEAD, '<'
    RET
NEXT_17:
    CMP AH, 4DH
    JNE NEXT_18
    CMP HEAD, '<'
    JE NEXT_18
    MOV HEAD,'>'
    RET
NEXT_18:    
    CMP DL, 'Q'
    JE QUIT_KEYBD_INPUT
    RET    
QUIT_KEYBD_INPUT:   
    ;CONDITIONS FOR QUITTING IN HERE PLEASE  
    INC QUIT
    RET
    
KEYBD_INPUT ENDP

SNAKE_MOVE PROC     
    MOV BX, OFFSET HEAD
    
    ;DETERMINE THE WHERE SHOULD THE HEAD GO SOLTI?
    ;PRESERVE THE HEAD
    XOR AX, AX
    MOV AL, [BX]
    PUSH AX
    INC BX
    MOV AX, [BX]
    INC BX    
    INC BX
    XOR CX, CX
L:      
    MOV SI, [BX]
    TEST SI, [BX]
    JZ OUTSIDE
    INC CX     
    INC BX
    MOV DX,[BX]
    MOV [BX], AX
    MOV AX,DX
    INC BX
    INC BX
    JMP L
    
OUTSIDE:    
    ;HOPEFULLY, THE SNAKE WILL BE SHIFTED, I.E. MOVED.
    ;NOW SHIFT THE HEAD IN ITS PROPER DIRECTION AND THEN CLEAR THE LAST SEGMENT. 
    ;BUT DON'T CLEAR THE LAST SEGMENT IF THE SNAKE HAS EATEN THE FRUIT
    POP AX
    ;AL CONTAINS THE SNAKE HEAD DIRECTION
    
    PUSH DX
    ;DX NOW CONSISTS THE COORDINATES OF THE LAST SEGMENT, WE CAN USE THIS TO CLEAR IT
    
    LEA BX, HEAD
    INC BX
    MOV DX, [BX]
    
    CMP AL, '<'
    JNE NEXT_1
    DEC DL
    DEC DL
    JMP DONE_CHECKING_THE_HEAD
NEXT_1:
    CMP AL, '>'
    JNE NEXT_2                
    INC DL 
    INC DL
    JMP DONE_CHECKING_THE_HEAD
NEXT_2:
    CMP AL, '^'
    JNE NEXT_3 
    DEC DH               
                  
    JMP DONE_CHECKING_THE_HEAD
    
NEXT_3:
    ;MUST BE 'V'
    INC DH
    
DONE_CHECKING_THE_HEAD:    
    MOV [BX],DX
    ;DX CONTAINS THE NEW POSITION OF THE HEAD, NOW CHECK WHATS IN THAT POSITION   
    CALL READ_CHAR ;DX
    ;BL CONTAINS THE RESULT
    
    CMP BL, '0'
    JE FOOD_EATEN
    
    ;IF FRUIT WAS NOT EATEN, THEN CLEAR THE LAST SEGMENT, 
    ;IT WILL BE CLEARED WHERE?
    MOV CX, DX
    POP DX 
    CMP BL, '*'    ;THE SNAKE BIT ITSELF, GAMEOVER
    JE GAME_OVER
    MOV BL, 0
    CALL PRINT_CHAR
    MOV DX, CX
    
    ;CHECK WHETHER THE SNAKE IS WITHIN THE BOUNDARY
    CMP DH, TOP
    JE GAME_OVER
    CMP DH, BOTTOM
    JE GAME_OVER
    CMP DL,LEFT
    JE GAME_OVER
    CMP DL, RIGHT
    JE GAME_OVER
    
    ;BALANCE THE STACK, NUMBER OF SEGMENT AND THE COORDINATE OF THE LAST SEGMENT
    
    RET
GAME_OVER:
    INC GAMEOVER
    RET
FOOD_EATEN:    

    ; ADD A NEW SEGMENT THEN
    MOV AL, CHAR_COUNT
    XOR AH, AH
    
    LEA BX, BODY
    MOV CX, 3
    MUL CX
    
    POP DX
    ADD BX, AX
    MOV BYTE PTR DS:[BX], '*'
    MOV [BX+1], DX
    INC CHAR_COUNT 
    MOV DH, FOOD_Y
    MOV DL, FOOD_X
    MOV BL, 0
    CALL PRINT_CHAR
    MOV FOOD_ACTIVE, 0   
    RET 
SNAKE_MOVE ENDP
   
;PRINTBOX
PRINT_BOARD PROC
;DRAW A BOX AROUND
    MOV DH, TOP
    MOV DL, LEFT
    MOV CX, COL
    MOV BL, '*'
L1:                 
    CALL PRINT_CHAR
    INC DL
    LOOP L1
    
    MOV CX, ROW
L2:
    CALL PRINT_CHAR
    INC DH
    LOOP L2
    
    MOV CX, COL
L3:
    CALL PRINT_CHAR
    DEC DL
    LOOP L3

    MOV CX, ROW     
L4:
    CALL PRINT_CHAR    
    DEC DH 
    LOOP L4    
    
    RET
PRINT_BOARD ENDP
              
;DX CONTAINS ROW, COL
;BL CONTAINS THE CHARACTER TO WRITE
;USES DI. 
PRINT_CHAR PROC
    ;80X25
    PUSH DX
    MOV AX, DX
    AND AX, 0FF00H
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    
    PUSH BX
    MOV BH, 160
    MUL BH 
    POP BX
    AND DX, 0FFH
    SHL DX,1
    ADD AX, DX
    MOV DI, AX
    MOV ES:[DI], BL
    POP DX
    RET    
PRINT_CHAR ENDP
            
;DX CONTAINS ROW,COL
;RETURNS THE CHARACTER AT BL
;USES DI
READ_CHAR PROC
    PUSH DX
    MOV AX, DX
    AND AX, 0FF00H
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1    
    PUSH BX
    MOV BH, 160
    MUL BH 
    POP BX
    AND DX, 0FFH
    SHL DX,1
    ADD AX, DX
    MOV DI, AX
    MOV BL,ES:[DI]
    POP DX
    RET
READ_CHAR ENDP        

;DX CONTAINS ROW, COL
;BX CONTAINS THE OFFSET OF THE STRING
PRINT_STRING PROC
    PUSH DX
    MOV AX, DX
    AND AX, 0FF00H
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    SHR AX,1
    
    PUSH BX
    MOV BH, 160
    MUL BH
    
    POP BX
    AND DX, 0FFH
    SHL DX,1
    ADD AX, DX
    MOV DI, AX
LOOP_PRINT_STRING:
    MOV AL, [BX]
    TEST AL, AL
    JZ EXIT_PRINT_STRING
    MOV ES:[DI], AL
    INC DI
    INC DI
    INC BX
    JMP LOOP_PRINT_STRING
    
EXIT_PRINT_STRING:
    POP DX
    RET
    
PRINT_STRING ENDP
     
MAIN ENDP
END MAIN
